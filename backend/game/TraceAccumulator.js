// Trace Accumulator for NEXUS PROTOCOL
// Calculates trace generation from actions

class TraceAccumulator {
  constructor() {
    // Base trace generation by tool category
    this.baseTraceByCategory = {
      reconnaissance: 8,      // Network scanning, enumeration
      exploitation: 15,       // Active exploitation attempts
      lateral_movement: 12,   // Moving between systems
      persistence: 10,        // Establishing backdoors
      exfiltration: 12,       // Data extraction
      privilege_escalation: 14 // Gaining elevated access
    };
    
    // Tool-specific trace modifiers
    this.toolTraceModifiers = {
      // Stealth tools (reduce trace)
      'mimikatz': 0.7,        // Memory-only, harder to detect
      'dns_tunnel': 0.5,      // Covert channel
      'cron_persistence': 0.8, // Subtle persistence
      
      // Noisy tools (increase trace)
      'nmap': 1.2,            // Network scanning is observable
      'sqlmap': 1.3,          // Active exploitation attempts
      'hydra': 1.4,           // Brute force is very noisy
      'metasploit': 1.5,      // Active exploitation framework
      
      // Moderate tools
      'gobuster': 1.0,
      'netcat': 1.0
    };
    
    // Observable action multiplier
    this.observableMultiplier = 1.5;
    
    // Agent specialization modifiers
    this.agentTraceModifiers = {
      'ARCHITECT': 1.0,  // Standard trace
      'SPECTER': 0.7,    // Stealth specialist - reduced trace
      'ORACLE': 0.9      // Intelligence specialist - slightly reduced trace
    };
  }

  /**
   * Calculate trace generated by an action
   * @param {Object} action - Action data
   * @returns {number} Trace amount generated
   */
  calculateTrace(action) {
    // Start with base trace
    let trace = this.getBaseTrace(action);
    
    // Apply tool-specific modifier
    trace = this.applyToolModifier(trace, action.toolId);
    
    // Apply agent specialization modifier
    trace = this.applyAgentModifier(trace, action.agentType);
    
    // Apply observable action multiplier
    if (action.observable) {
      trace *= this.observableMultiplier;
    }
    
    // Apply success/failure modifier
    if (!action.success) {
      trace *= 0.5; // Failed actions generate less trace
    }
    
    // Apply effectiveness modifier (lower effectiveness = more trace)
    if (action.effectiveness) {
      const effectivenessModifier = 0.8 + (action.effectiveness * 0.4);
      trace *= effectivenessModifier;
    }
    
    // Apply random variation (±15%)
    const variation = 0.85 + (Math.random() * 0.3);
    trace *= variation;
    
    // Round to integer
    return Math.max(1, Math.round(trace));
  }

  /**
   * Get base trace for an action
   * @param {Object} action - Action data
   * @returns {number} Base trace
   */
  getBaseTrace(action) {
    // If action has explicit trace generation, use it
    if (action.traceGeneration !== undefined) {
      return action.traceGeneration;
    }
    
    // Otherwise, use category-based trace
    const category = action.category || 'reconnaissance';
    return this.baseTraceByCategory[category] || 10;
  }

  /**
   * Apply tool-specific modifier
   * @param {number} trace - Current trace
   * @param {string} toolId - Tool identifier
   * @returns {number} Modified trace
   */
  applyToolModifier(trace, toolId) {
    if (!toolId) {
      return trace;
    }
    
    const modifier = this.toolTraceModifiers[toolId] || 1.0;
    return trace * modifier;
  }

  /**
   * Apply agent specialization modifier
   * @param {number} trace - Current trace
   * @param {string} agentType - Agent type
   * @returns {number} Modified trace
   */
  applyAgentModifier(trace, agentType) {
    if (!agentType) {
      return trace;
    }
    
    const modifier = this.agentTraceModifiers[agentType] || 1.0;
    return trace * modifier;
  }

  /**
   * Calculate trace reduction from stealth tools
   * @param {Object} action - Stealth action data
   * @returns {number} Trace reduction amount
   */
  calculateTraceReduction(action) {
    // Base reduction by tool
    const baseReduction = {
      'mimikatz': 15,      // Memory-only operations
      'dns_tunnel': 20,    // Covert exfiltration
      'cron_persistence': 10 // Subtle persistence
    };
    
    const reduction = baseReduction[action.toolId] || 5;
    
    // Apply agent modifier
    let finalReduction = reduction;
    if (action.agentType === 'SPECTER') {
      finalReduction *= 1.5; // SPECTER is stealth specialist
    }
    
    // Apply success modifier
    if (!action.success) {
      finalReduction *= 0.3; // Failed stealth actions don't reduce much trace
    }
    
    // Random variation (±20%)
    const variation = 0.8 + (Math.random() * 0.4);
    finalReduction *= variation;
    
    return Math.max(1, Math.round(finalReduction));
  }

  /**
   * Calculate trace from time decay
   * @param {number} minutesElapsed - Minutes since last action
   * @param {number} currentTrace - Current trace level
   * @returns {number} Trace decay amount
   */
  calculateTimeDecay(minutesElapsed, currentTrace) {
    // Trace decays slowly over time
    // Higher trace levels decay faster
    const baseDecayRate = 0.5; // 0.5 trace per minute
    const traceMultiplier = 1 + (currentTrace / 200); // Faster decay at high trace
    
    const decay = minutesElapsed * baseDecayRate * traceMultiplier;
    return Math.round(decay);
  }

  /**
   * Calculate trace from detection event
   * @param {Object} detectionData - Detection event data
   * @returns {number} Additional trace from being detected
   */
  calculateDetectionTrace(detectionData) {
    // Being detected increases trace
    const severityMultipliers = {
      'low': 5,
      'medium': 10,
      'high': 15,
      'critical': 20
    };
    
    const severity = detectionData.severity || 'medium';
    return severityMultipliers[severity] || 10;
  }

  /**
   * Get trace breakdown for an action
   * @param {Object} action - Action data
   * @returns {Object} Trace calculation breakdown
   */
  getTraceBreakdown(action) {
    const baseTrace = this.getBaseTrace(action);
    const toolModifier = this.toolTraceModifiers[action.toolId] || 1.0;
    const agentModifier = this.agentTraceModifiers[action.agentType] || 1.0;
    const observableMultiplier = action.observable ? this.observableMultiplier : 1.0;
    const successModifier = action.success ? 1.0 : 0.5;
    const effectivenessModifier = action.effectiveness 
      ? (0.8 + (action.effectiveness * 0.4))
      : 1.0;
    
    const finalTrace = Math.round(
      baseTrace * 
      toolModifier * 
      agentModifier * 
      observableMultiplier * 
      successModifier * 
      effectivenessModifier
    );
    
    return {
      baseTrace,
      toolModifier,
      agentModifier,
      observableMultiplier,
      successModifier,
      effectivenessModifier,
      finalTrace,
      breakdown: {
        base: `${baseTrace} (category: ${action.category || 'unknown'})`,
        tool: `×${toolModifier} (${action.toolId || 'none'})`,
        agent: `×${agentModifier} (${action.agentType || 'none'})`,
        observable: `×${observableMultiplier} (${action.observable ? 'yes' : 'no'})`,
        success: `×${successModifier} (${action.success ? 'success' : 'failed'})`,
        effectiveness: `×${effectivenessModifier.toFixed(2)} (${action.effectiveness ? Math.round(action.effectiveness * 100) + '%' : 'N/A'})`,
        final: `= ${finalTrace} trace`
      }
    };
  }

  /**
   * Predict trace for a planned action
   * @param {Object} actionPlan - Planned action data
   * @returns {Object} Predicted trace
   */
  predictTrace(actionPlan) {
    // Calculate expected trace assuming success
    const successAction = { ...actionPlan, success: true };
    const successTrace = this.calculateTrace(successAction);
    
    // Calculate trace if action fails
    const failureAction = { ...actionPlan, success: false };
    const failureTrace = this.calculateTrace(failureAction);
    
    return {
      expectedTrace: successTrace,
      failureTrace,
      range: {
        min: Math.round(failureTrace * 0.85),
        max: Math.round(successTrace * 1.15)
      },
      recommendation: this.getTraceRecommendation(successTrace, actionPlan)
    };
  }

  /**
   * Get recommendation based on predicted trace
   * @param {number} predictedTrace - Predicted trace amount
   * @param {Object} actionPlan - Action plan
   * @returns {string} Recommendation
   */
  getTraceRecommendation(predictedTrace, actionPlan) {
    if (predictedTrace < 10) {
      return 'Low trace generation - safe to proceed';
    } else if (predictedTrace < 15) {
      return 'Moderate trace generation - proceed with caution';
    } else if (predictedTrace < 20) {
      return 'High trace generation - consider stealth alternatives';
    } else {
      return 'Very high trace generation - high risk of detection';
    }
  }

  /**
   * Get stealth recommendations
   * @param {string} agentType - Agent type
   * @returns {Array} Stealth recommendations
   */
  getStealthRecommendations(agentType) {
    const recommendations = [
      'Use stealth tools (mimikatz, dns_tunnel) to reduce trace',
      'Avoid observable actions when possible',
      'Space out actions to allow trace decay',
      'Monitor burn state and adjust tactics accordingly'
    ];
    
    if (agentType === 'SPECTER') {
      recommendations.unshift('Leverage SPECTER\'s stealth specialization for reduced trace');
    }
    
    return recommendations;
  }
}

module.exports = TraceAccumulator;
