// Trace & Burn System for NEXUS PROTOCOL
// Manages identity residue tracking and burn state calculation

const { v4: uuidv4 } = require('uuid');

class TraceBurnSystem {
  constructor(traceAccumulator, burnCalculator) {
    this.traceAccumulator = traceAccumulator;
    this.burnCalculator = burnCalculator;
    this.roundTraceData = new Map(); // roundId -> trace data
    
    // Trace level thresholds
    this.traceLevels = {
      GHOST: { min: 0, max: 25, name: 'Ghost', description: 'Minimal identity residue' },
      SHADOW: { min: 26, max: 50, name: 'Shadow', description: 'Moderate identity residue' },
      VISIBLE: { min: 51, max: 75, name: 'Visible', description: 'Significant identity residue' },
      BURNED: { min: 76, max: 100, name: 'Burned', description: 'Critical identity exposure' }
    };
    
    // Burn state thresholds (based on absolute trace value, not percentage)
    this.burnStates = {
      LOW: { threshold: 0, name: 'LOW', color: 'green', effectivenessModifier: 1.0 },
      MODERATE: { threshold: 50, name: 'MODERATE', color: 'yellow', effectivenessModifier: 0.85 },
      HIGH: { threshold: 100, name: 'HIGH', color: 'orange', effectivenessModifier: 0.65 },
      CRITICAL: { threshold: 200, name: 'CRITICAL', color: 'red', effectivenessModifier: 0.40 }
    };
  }

  /**
   * Initialize trace tracking for a round
   * @param {string} roundId - Round identifier
   * @param {string} teamId - Team identifier (red team)
   */
  initializeRound(roundId, teamId) {
    this.roundTraceData.set(roundId, {
      roundId,
      teamId,
      totalTrace: 0,
      traceLevel: 'GHOST',
      burnState: 'LOW',
      traceHistory: [],
      stealthActions: 0,
      observableActions: 0,
      detectionEvents: 0,
      lastUpdate: new Date()
    });
  }

  /**
   * Accumulate trace from an action
   * @param {string} roundId - Round identifier
   * @param {Object} action - Action that generated trace
   * @returns {Object} Trace accumulation result
   */
  accumulateTrace(roundId, action) {
    const traceData = this.roundTraceData.get(roundId);
    if (!traceData) {
      throw new Error('Round not initialized for trace tracking');
    }

    // Calculate trace generated by this action
    const traceGenerated = this.traceAccumulator.calculateTrace(action);
    
    // Update total trace
    const previousTrace = traceData.totalTrace;
    const previousLevel = traceData.traceLevel;
    const previousBurnState = traceData.burnState;
    
    traceData.totalTrace += traceGenerated;
    
    // Calculate new trace level and burn state
    const newTraceLevel = this.getTraceLevelFromValue(traceData.totalTrace);
    const newBurnState = this.burnCalculator.calculateBurnState(traceData.totalTrace);
    
    // Update trace data
    traceData.traceLevel = newTraceLevel;
    traceData.burnState = newBurnState;
    traceData.lastUpdate = new Date();
    
    // Track action type
    if (action.observable) {
      traceData.observableActions++;
    } else {
      traceData.stealthActions++;
    }
    
    // Record in history
    const historyEntry = {
      id: uuidv4(),
      timestamp: new Date(),
      action: action.type || action.toolId,
      traceGenerated,
      totalTrace: traceData.totalTrace,
      traceLevel: newTraceLevel,
      burnState: newBurnState,
      observable: action.observable
    };
    
    traceData.traceHistory.push(historyEntry);
    
    // Limit history size
    if (traceData.traceHistory.length > 100) {
      traceData.traceHistory.shift();
    }
    
    return {
      success: true,
      traceGenerated,
      previousTrace,
      currentTrace: traceData.totalTrace,
      previousLevel,
      currentLevel: newTraceLevel,
      levelChanged: previousLevel !== newTraceLevel,
      previousBurnState,
      currentBurnState: newBurnState,
      burnStateChanged: previousBurnState !== newBurnState,
      detectionProbability: this.burnCalculator.getDetectionProbability(newBurnState),
      effectivenessModifier: this.burnCalculator.getToolEffectivenessPenalty(newBurnState)
    };
  }

  /**
   * Reduce trace (from stealth tools or time decay)
   * @param {string} roundId - Round identifier
   * @param {number} amount - Amount to reduce
   * @param {string} reason - Reason for reduction
   * @returns {Object} Trace reduction result
   */
  reduceTrace(roundId, amount, reason = 'stealth_tool') {
    const traceData = this.roundTraceData.get(roundId);
    if (!traceData) {
      throw new Error('Round not initialized for trace tracking');
    }

    const previousTrace = traceData.totalTrace;
    const previousLevel = traceData.traceLevel;
    const previousBurnState = traceData.burnState;
    
    // Reduce trace (minimum 0)
    traceData.totalTrace = Math.max(0, traceData.totalTrace - amount);
    
    // Recalculate levels
    const newTraceLevel = this.getTraceLevelFromValue(traceData.totalTrace);
    const newBurnState = this.burnCalculator.calculateBurnState(traceData.totalTrace);
    
    traceData.traceLevel = newTraceLevel;
    traceData.burnState = newBurnState;
    traceData.lastUpdate = new Date();
    
    // Record in history
    const historyEntry = {
      id: uuidv4(),
      timestamp: new Date(),
      action: 'trace_reduction',
      reason,
      traceReduced: amount,
      totalTrace: traceData.totalTrace,
      traceLevel: newTraceLevel,
      burnState: newBurnState
    };
    
    traceData.traceHistory.push(historyEntry);
    
    return {
      success: true,
      traceReduced: amount,
      previousTrace,
      currentTrace: traceData.totalTrace,
      previousLevel,
      currentLevel: newTraceLevel,
      levelChanged: previousLevel !== newTraceLevel,
      previousBurnState,
      currentBurnState: newBurnState,
      burnStateChanged: previousBurnState !== newBurnState
    };
  }

  /**
   * Get trace level from numeric value
   * @param {number} traceValue - Trace value
   * @returns {string} Trace level name
   */
  getTraceLevelFromValue(traceValue) {
    // Calculate percentage (assuming max trace of 400 = 100%)
    const maxTrace = 400;
    const percentage = Math.min(100, (traceValue / maxTrace) * 100);
    
    if (percentage <= 25) return 'GHOST';
    if (percentage <= 50) return 'SHADOW';
    if (percentage <= 75) return 'VISIBLE';
    return 'BURNED';
  }

  /**
   * Get trace level details
   * @param {string} levelName - Level name
   * @returns {Object} Level details
   */
  getTraceLevelDetails(levelName) {
    return this.traceLevels[levelName] || this.traceLevels.GHOST;
  }

  /**
   * Get burn state details
   * @param {string} stateName - State name
   * @returns {Object} State details
   */
  getBurnStateDetails(stateName) {
    return this.burnStates[stateName] || this.burnStates.LOW;
  }

  /**
   * Get current trace data for a round
   * @param {string} roundId - Round identifier
   * @returns {Object} Trace data
   */
  getTraceData(roundId) {
    const traceData = this.roundTraceData.get(roundId);
    if (!traceData) {
      return null;
    }

    const traceLevelDetails = this.getTraceLevelDetails(traceData.traceLevel);
    const burnStateDetails = this.getBurnStateDetails(traceData.burnState);
    
    return {
      roundId: traceData.roundId,
      teamId: traceData.teamId,
      totalTrace: traceData.totalTrace,
      traceLevel: traceData.traceLevel,
      traceLevelDetails,
      burnState: traceData.burnState,
      burnStateDetails,
      tracePercentage: Math.min(100, (traceData.totalTrace / 400) * 100),
      detectionProbability: this.burnCalculator.getDetectionProbability(traceData.burnState),
      effectivenessModifier: this.burnCalculator.getToolEffectivenessPenalty(traceData.burnState),
      stealthActions: traceData.stealthActions,
      observableActions: traceData.observableActions,
      detectionEvents: traceData.detectionEvents,
      lastUpdate: traceData.lastUpdate
    };
  }

  /**
   * Get trace history for a round
   * @param {string} roundId - Round identifier
   * @param {number} limit - Maximum number of entries
   * @returns {Array} Trace history
   */
  getTraceHistory(roundId, limit = 20) {
    const traceData = this.roundTraceData.get(roundId);
    if (!traceData) {
      return [];
    }

    return traceData.traceHistory.slice(-limit);
  }

  /**
   * Record a detection event
   * @param {string} roundId - Round identifier
   * @param {Object} detectionData - Detection event data
   */
  recordDetection(roundId, detectionData) {
    const traceData = this.roundTraceData.get(roundId);
    if (!traceData) {
      return;
    }

    traceData.detectionEvents++;
    
    // Record in history
    const historyEntry = {
      id: uuidv4(),
      timestamp: new Date(),
      action: 'detection_event',
      detectionType: detectionData.type,
      severity: detectionData.severity,
      totalTrace: traceData.totalTrace,
      traceLevel: traceData.traceLevel,
      burnState: traceData.burnState
    };
    
    traceData.traceHistory.push(historyEntry);
  }

  /**
   * Apply time-based trace decay
   * @param {string} roundId - Round identifier
   * @param {number} decayRate - Decay rate per minute
   * @returns {Object} Decay result
   */
  applyTraceDecay(roundId, decayRate = 1) {
    const traceData = this.roundTraceData.get(roundId);
    if (!traceData) {
      return { success: false, error: 'Round not found' };
    }

    // Calculate time since last update
    const now = new Date();
    const timeSinceUpdate = (now - traceData.lastUpdate) / 1000 / 60; // minutes
    
    // Calculate decay amount
    const decayAmount = Math.floor(timeSinceUpdate * decayRate);
    
    if (decayAmount > 0) {
      return this.reduceTrace(roundId, decayAmount, 'time_decay');
    }
    
    return { success: true, decayAmount: 0 };
  }

  /**
   * Get trace statistics for a round
   * @param {string} roundId - Round identifier
   * @returns {Object} Statistics
   */
  getTraceStatistics(roundId) {
    const traceData = this.roundTraceData.get(roundId);
    if (!traceData) {
      return null;
    }

    const history = traceData.traceHistory;
    const traceGeneratingActions = history.filter(h => h.traceGenerated > 0);
    
    const avgTracePerAction = traceGeneratingActions.length > 0
      ? traceGeneratingActions.reduce((sum, h) => sum + h.traceGenerated, 0) / traceGeneratingActions.length
      : 0;
    
    const maxTraceAction = traceGeneratingActions.length > 0
      ? Math.max(...traceGeneratingActions.map(h => h.traceGenerated))
      : 0;
    
    return {
      totalTrace: traceData.totalTrace,
      traceLevel: traceData.traceLevel,
      burnState: traceData.burnState,
      totalActions: history.length,
      stealthActions: traceData.stealthActions,
      observableActions: traceData.observableActions,
      detectionEvents: traceData.detectionEvents,
      averageTracePerAction: Math.round(avgTracePerAction * 10) / 10,
      maxTraceFromSingleAction: maxTraceAction,
      traceReductions: history.filter(h => h.action === 'trace_reduction').length
    };
  }

  /**
   * Cleanup trace data for a round
   * @param {string} roundId - Round identifier
   */
  cleanup(roundId) {
    this.roundTraceData.delete(roundId);
  }

  /**
   * Get all active rounds
   * @returns {Array} Round IDs
   */
  getActiveRounds() {
    return Array.from(this.roundTraceData.keys());
  }
}

module.exports = TraceBurnSystem;
